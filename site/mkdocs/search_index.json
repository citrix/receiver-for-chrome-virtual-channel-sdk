{
    "docs": [
        {
            "location": "/", 
            "text": "Citrix Virtual Channel SDK for Citrix Receiver for Chrome\n\n\nThe Citrix Virtual Channel Software Development Kit (SDK) provides support for writing server-side applications and client-side drivers for additional virtual channels using the ICA protocol. The server-side virtual channel applications are on XenApp or XenDesktop servers. This version of the SDK provides support for writing new virtual channels for Receiver for Chrome. If you want to write virtual drivers for other client platforms, contact Citrix.\n\n\nThe Virtual Channel SDK provides:\n\n\n\n\nAn easy interface that can be used with the virtual channels in the Citrix Server API SDK (WFAPI SDK) to create new virtual channels.\n\n\nWorking source code for several virtual channel sample programs that demonstrate programming techniques.\n\n\nThe Virtual Channel SDK requires the WFAPI SDK to write the server side of the virtual channel.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#citrix-virtual-channel-sdk-for-citrix-receiver-for-chrome", 
            "text": "The Citrix Virtual Channel Software Development Kit (SDK) provides support for writing server-side applications and client-side drivers for additional virtual channels using the ICA protocol. The server-side virtual channel applications are on XenApp or XenDesktop servers. This version of the SDK provides support for writing new virtual channels for Receiver for Chrome. If you want to write virtual drivers for other client platforms, contact Citrix.  The Virtual Channel SDK provides:   An easy interface that can be used with the virtual channels in the Citrix Server API SDK (WFAPI SDK) to create new virtual channels.  Working source code for several virtual channel sample programs that demonstrate programming techniques.  The Virtual Channel SDK requires the WFAPI SDK to write the server side of the virtual channel.", 
            "title": "Citrix Virtual Channel SDK for Citrix Receiver for Chrome"
        }, 
        {
            "location": "/system-requirements/", 
            "text": "System requirements\n\n\nThird-party Chrome app must be implemented to add a new virtual channel. Virtual Channel SDK is a JavaScript file that should be included in the third-party Chrome app preferably in the background page. Adding the Virtual Channel SDK in the background page ensures that the Virtual Channel is added to the session regardless of the third-party Chrome app running or not. If virtual channel SDK is added as a part of non-background window, then virtual channel connection is established only when that window is active. \n\n\nUp to three client side virtual channels are supported where the virtual channel implementation of each virtual channel might be part of the same third-party Chrome app or different app.\n\n\nIDs of all the third-party Chrome apps and the virtual channel stream name must be set in the Receiver for Chrome configuration before launch of a session. \n\n\nYou can use any supported configuration methods. However, Citrix recommends you to use Google Admin Console.  Third-party Chrome app must register the custom virtual channel using the Virtual Channel SDK before launching a HDX app/desktop sessions. Otherwise, the custom virtual channel is not initialized with the launched session. For more details, see \nProgramming Guide\n.\n\n\nExecution Environment Requirements\n\n\nServer requirement\n\n\nThe Receiver for Chrome Virtual Channel SDK is supported on Citrix XenApp 6.5 (and later) and Citrix XenDesktop 7.6 (and later).\n\n\nClient requirement\n\n\nCitrix Receiver for Chrome 2.5 and later\n\n\nArchitecture\n\n\nA Citrix Independent Computing Architecture (ICA) virtual channel is a bidirectional, error-free connection for the exchange of generalized packet data between a server running Citrix XenApp or XenDesktop, and a client device. You can use virtual channels to add functionality to clients. Uses for virtual channels include:\n\n\n\n\nSupport for administrative functions\n\n\nNew data streams (audio and video)\n\n\nNew devices, such as scanners, card readers, and joysticks\n\n\n\n\nVirtual Channel Overview\n\n\nAn ICA virtual channel is a bidirectional, error-free connection for the exchange of generalized packet data between a client and a server running XenApp or XenDesktop. Each implementation of an ICA virtual channel consists of two components:\n\n\nServer-side portion on the computer running XenApp or XenDesktop\n\n\nThe virtual channel on the server side is a normal Win32 process. It can be an application or a Windows NT service.\n\n\nClient-side\n\n\nThe client side custom virtual driver executes in the context of the client. You must implement the virtual driver by including virtual channel SDK JavaScript file in the Chrome packaged app. When you configure Citrix Receiver for Chrome using the Chrome packaged app id and the virtual channel name, Citrix Receiver for Chrome communicates with the Chrome packaged app by sending messages with the help of SDK and calls the appropriate callbacks provided at the time of registering the virtual channel. The Chrome packaged app must be installed and the virtual channel must be registered before launching a Citrix Receiver for Chrome session.\n\n\nYou can either have different Chrome packaged app for each virtual channel or one Chrome packaged app with all the virtual channel implementation. Each virtual channel should register separately in your Chrome packaged app and receiver for Chrome should be configured accordingly.\n\n\nThis figure illustrates the virtual channel client-server connection:\n\n\n\n\nCitrix Receiver for Chrome Virtual Channel SDK is responsible for de-multiplexing the virtual channel data from the ICA data stream and routing it to the correct callback of the registered virtual channel. It is also responsible for sending the data using the appropriate object to the server in coordination with the Citrix Receiver for Chrome. Citrix Receiver for Chrome does not know any data package detail for each virtual channel and it only transfers all available data between the server and the client virtual driver.\n\n\nThe following is an overview of the client-server data exchange using a virtual channel:\n\n\n\n\nThe client connects to the server running XenApp or XenDesktop. The client passes information about the virtual channels that it supports to the server.\n\n\nThe server-side application starts, obtains a handle to the virtual channel, and optionally queries for additional information about the channel.\n\n\nBoth the client-side virtual driver and server-side application can send data initiatively:\n\n\nIf the server application has data to send to the client, the data is sent to the client immediately. When the client receives the data, Citrix Receiver for Chrome de-multiplexes the virtual channel data from the ICA stream and passes to the third-party Chrome app implementing the virtual channel. Virtual Channel SDK routes the data to the appropriate callback of the registered object for that Virtual channel.\n\n\nIf the client virtual driver has data to send to the server, the data is also sent immediately.\n\n\n\n\n\n\nWhen the ICA session disconnects or something unexpected occurs, such as runtime exceptions or errors, the virtual channel closes and the client virtual driver (third-party Chrome app) disconnects from Citrix Receiver for Chrome.\n\n\n\n\nICA and Virtual Channel Data Packets\n\n\nVirtual channel data packets are encapsulated in the ICA stream between the client and the server. Because ICA is a presentation-level protocol and runs over several different transports, the virtual channel API enables you to write your protocols without worrying about the underlying transport. The data packet is preserved.\n\n\nFor example, if 100 bytes are sent to the server, the same 100 bytes are received by the server when the virtual channel is demultiplexed from the ICA data stream. The compiled code runs independently of the currently configured transport protocol.\nThe ICA engine provides the following services to the virtual channel:\n\n\nPacket encapsulation\n\n\nICA virtual channels are packet-based, meaning that if one side performs a write with a certain amount of data, the other side receives the entire block of data when it performs a read. This contrasts with TCP, for example, which is stream-based and requires a higher-level protocol to parse out packet boundaries. Stated another way, virtual channel packets are contained within the ICA stream, which is managed separately by the system software.\n\n\nError correction\n\n\nICA provides its own reliability mechanisms even when the underlying transport is unreliable. This guarantees that connections are error-free and that data is received in the order in which it is sent.\n\n\nReceiver and Virtual Driver Interaction\n\n\nIn Citrix Receiver for Chrome, the custom virtual driver is implemented as a third-party Chrome packaged app and must be installed on the Chrome device before an ICA session is launched. Third-party Chrome packaged app needs to include the Virtual Channel SDK JavaScript file and register to the Virtual Channel by giving appropriate parameters. In addition, the third-party Chrome app implementing the virtual channel and the name of the virtual channel has to be configured for Citrix Receiver for Chrome to bind. When you launch an ICA session, Citrix Receiver for Chrome queries each Virtual Channel by sending messages to the third-party Chrome app. SDK calls the functions registered for different messages and the third-party Chrome app needs to respond with the replies in the format defined. If the third-party Chrome app is not installed or the Virtual Channel is not registered with the SDK or the Citrix Receiver for Chrome is not configured correctly, then the Virtual Channel is not initialized but the sessions would be launched. \n\n\nAs a note the virtual driver that you write must never block or perform time-consuming tasks in the driver operations like open, get info, ICA data arrival.\nFor more information about building Chrome packaged app, see the Chrome developer documentation.\n\n\nThe following process occurs when a user starts a session (Following happens for each session and for each virtual channel registered):\n\n\n\n\nOn a session launch, using the configuration the app ids and the stream names are fetched. This is used by the session for binding the Virtual Channel between the third-party Chrome app and Citrix Receiver for Chrome session.\n\n\nSession sends a message when the virtual channel is initialized to the third-party Chrome app. The Virtual Channel SDK handles the message and calls the callback set for the \ndriverOpen\n during virtual channel registration by giving session Id and stream name. Callback present in the third-party Chrome app must reply with enable flag set to \ntrue\n or \nfalse\n along with the \nsessionId\n and the virtual channel name. If enable is set to \ntrue\n, further initialization of the virtual channel happens. Otherwise the virtual channel is ignored. If the virtual channel is not registered with SDK then the virtual channel is ignored.\n\n\nOn sending enable \ntrue\n, session would send another message to collect the virtual channel information that must be sent to server during initialization. SDK would get the message and call the callback registered for driver info of the registered vc object. Callback present in third-party Chrome app must reply with the appropriate packet if applicable or reply with null.\n\n\nSession would send all the capabilities to the server and on successful initialization of virtual channel any data sent by server to Citrix Receiver for Chrome session is forwarded to the Virtual Channel SDK.  Virtual Channel SDK calls the \nicaDataArrival\n callback of the registered virtual channel object. Callback should parse the packet and send the reply packet using \nsendData\n method of the registered virtual channel object. Utils has been provided to make packet reading and construction of reply packet easier.\n\n\nOn disconnect of the session or the reload/crash/uninstall of the third-party Chrome app Virtual Channel SDK calls the \ndriverClose\n callback of the third-party Chrome app with appropriate session Id and stream name. Can be used to handle any cleanup of the virtual channel for that session. \n\n\n\n\nSee also\n\n\n\n\nFor sample example, see the \ndownload\n page.\n\n\nFor details on signature and usage of APIs, see the \nProgramming Guide\n. \n\n\n\n\nVirtual Channel Packets\n\n\nICA does not define the contents of a virtual channel packet. The contents are specific to the particular virtual channel and are not interpreted or managed by the ICA data stream manager. You must develop your own protocol for the virtual channel data.\n\n\nA virtual channel packet can be any length up to the maximum size supported by the ICA connection. This size is independent of size restrictions on the lower-layer transport. These restrictions affect the server-side WFVirtualChannelRead and WFVirtualChannelWrite functions and sendData callback on the client side. The maximum packet size is 5000 bytes (4996 data bytes plus 4 bytes of packet overhead generated by the ICA datastream manager).\n\n\nBecause Citrix Receiver for Chrome and the Virtual Channel SDK for Chrome are not aware of the details of the virtual channel package, they pass all available data in the ICA stream to the virtual driver by calling \nicaDataArrival\n. Packets received by the icaDataArrival function of the virtual channel are Uint8Arrays with appropriate details of offset and length. The virtual channel also needs to send the data to server in the same format. \nThe session creates a port connection using Chrome APIs and the data is sent/received over this port. Maximum size of the data that can be sent/received is dependent on the Chrome OS implementation.", 
            "title": "System requirements"
        }, 
        {
            "location": "/system-requirements/#system-requirements", 
            "text": "Third-party Chrome app must be implemented to add a new virtual channel. Virtual Channel SDK is a JavaScript file that should be included in the third-party Chrome app preferably in the background page. Adding the Virtual Channel SDK in the background page ensures that the Virtual Channel is added to the session regardless of the third-party Chrome app running or not. If virtual channel SDK is added as a part of non-background window, then virtual channel connection is established only when that window is active.   Up to three client side virtual channels are supported where the virtual channel implementation of each virtual channel might be part of the same third-party Chrome app or different app.  IDs of all the third-party Chrome apps and the virtual channel stream name must be set in the Receiver for Chrome configuration before launch of a session.   You can use any supported configuration methods. However, Citrix recommends you to use Google Admin Console.  Third-party Chrome app must register the custom virtual channel using the Virtual Channel SDK before launching a HDX app/desktop sessions. Otherwise, the custom virtual channel is not initialized with the launched session. For more details, see  Programming Guide .", 
            "title": "System requirements"
        }, 
        {
            "location": "/system-requirements/#execution-environment-requirements", 
            "text": "", 
            "title": "Execution Environment Requirements"
        }, 
        {
            "location": "/system-requirements/#server-requirement", 
            "text": "The Receiver for Chrome Virtual Channel SDK is supported on Citrix XenApp 6.5 (and later) and Citrix XenDesktop 7.6 (and later).", 
            "title": "Server requirement"
        }, 
        {
            "location": "/system-requirements/#client-requirement", 
            "text": "Citrix Receiver for Chrome 2.5 and later", 
            "title": "Client requirement"
        }, 
        {
            "location": "/system-requirements/#architecture", 
            "text": "A Citrix Independent Computing Architecture (ICA) virtual channel is a bidirectional, error-free connection for the exchange of generalized packet data between a server running Citrix XenApp or XenDesktop, and a client device. You can use virtual channels to add functionality to clients. Uses for virtual channels include:   Support for administrative functions  New data streams (audio and video)  New devices, such as scanners, card readers, and joysticks", 
            "title": "Architecture"
        }, 
        {
            "location": "/system-requirements/#virtual-channel-overview", 
            "text": "An ICA virtual channel is a bidirectional, error-free connection for the exchange of generalized packet data between a client and a server running XenApp or XenDesktop. Each implementation of an ICA virtual channel consists of two components:", 
            "title": "Virtual Channel Overview"
        }, 
        {
            "location": "/system-requirements/#server-side-portion-on-the-computer-running-xenapp-or-xendesktop", 
            "text": "The virtual channel on the server side is a normal Win32 process. It can be an application or a Windows NT service.", 
            "title": "Server-side portion on the computer running XenApp or XenDesktop"
        }, 
        {
            "location": "/system-requirements/#client-side", 
            "text": "The client side custom virtual driver executes in the context of the client. You must implement the virtual driver by including virtual channel SDK JavaScript file in the Chrome packaged app. When you configure Citrix Receiver for Chrome using the Chrome packaged app id and the virtual channel name, Citrix Receiver for Chrome communicates with the Chrome packaged app by sending messages with the help of SDK and calls the appropriate callbacks provided at the time of registering the virtual channel. The Chrome packaged app must be installed and the virtual channel must be registered before launching a Citrix Receiver for Chrome session.  You can either have different Chrome packaged app for each virtual channel or one Chrome packaged app with all the virtual channel implementation. Each virtual channel should register separately in your Chrome packaged app and receiver for Chrome should be configured accordingly.  This figure illustrates the virtual channel client-server connection:   Citrix Receiver for Chrome Virtual Channel SDK is responsible for de-multiplexing the virtual channel data from the ICA data stream and routing it to the correct callback of the registered virtual channel. It is also responsible for sending the data using the appropriate object to the server in coordination with the Citrix Receiver for Chrome. Citrix Receiver for Chrome does not know any data package detail for each virtual channel and it only transfers all available data between the server and the client virtual driver.  The following is an overview of the client-server data exchange using a virtual channel:   The client connects to the server running XenApp or XenDesktop. The client passes information about the virtual channels that it supports to the server.  The server-side application starts, obtains a handle to the virtual channel, and optionally queries for additional information about the channel.  Both the client-side virtual driver and server-side application can send data initiatively:  If the server application has data to send to the client, the data is sent to the client immediately. When the client receives the data, Citrix Receiver for Chrome de-multiplexes the virtual channel data from the ICA stream and passes to the third-party Chrome app implementing the virtual channel. Virtual Channel SDK routes the data to the appropriate callback of the registered object for that Virtual channel.  If the client virtual driver has data to send to the server, the data is also sent immediately.    When the ICA session disconnects or something unexpected occurs, such as runtime exceptions or errors, the virtual channel closes and the client virtual driver (third-party Chrome app) disconnects from Citrix Receiver for Chrome.", 
            "title": "Client-side"
        }, 
        {
            "location": "/system-requirements/#ica-and-virtual-channel-data-packets", 
            "text": "Virtual channel data packets are encapsulated in the ICA stream between the client and the server. Because ICA is a presentation-level protocol and runs over several different transports, the virtual channel API enables you to write your protocols without worrying about the underlying transport. The data packet is preserved.  For example, if 100 bytes are sent to the server, the same 100 bytes are received by the server when the virtual channel is demultiplexed from the ICA data stream. The compiled code runs independently of the currently configured transport protocol.\nThe ICA engine provides the following services to the virtual channel:", 
            "title": "ICA and Virtual Channel Data Packets"
        }, 
        {
            "location": "/system-requirements/#packet-encapsulation", 
            "text": "ICA virtual channels are packet-based, meaning that if one side performs a write with a certain amount of data, the other side receives the entire block of data when it performs a read. This contrasts with TCP, for example, which is stream-based and requires a higher-level protocol to parse out packet boundaries. Stated another way, virtual channel packets are contained within the ICA stream, which is managed separately by the system software.", 
            "title": "Packet encapsulation"
        }, 
        {
            "location": "/system-requirements/#error-correction", 
            "text": "ICA provides its own reliability mechanisms even when the underlying transport is unreliable. This guarantees that connections are error-free and that data is received in the order in which it is sent.", 
            "title": "Error correction"
        }, 
        {
            "location": "/system-requirements/#receiver-and-virtual-driver-interaction", 
            "text": "In Citrix Receiver for Chrome, the custom virtual driver is implemented as a third-party Chrome packaged app and must be installed on the Chrome device before an ICA session is launched. Third-party Chrome packaged app needs to include the Virtual Channel SDK JavaScript file and register to the Virtual Channel by giving appropriate parameters. In addition, the third-party Chrome app implementing the virtual channel and the name of the virtual channel has to be configured for Citrix Receiver for Chrome to bind. When you launch an ICA session, Citrix Receiver for Chrome queries each Virtual Channel by sending messages to the third-party Chrome app. SDK calls the functions registered for different messages and the third-party Chrome app needs to respond with the replies in the format defined. If the third-party Chrome app is not installed or the Virtual Channel is not registered with the SDK or the Citrix Receiver for Chrome is not configured correctly, then the Virtual Channel is not initialized but the sessions would be launched.   As a note the virtual driver that you write must never block or perform time-consuming tasks in the driver operations like open, get info, ICA data arrival.\nFor more information about building Chrome packaged app, see the Chrome developer documentation.  The following process occurs when a user starts a session (Following happens for each session and for each virtual channel registered):   On a session launch, using the configuration the app ids and the stream names are fetched. This is used by the session for binding the Virtual Channel between the third-party Chrome app and Citrix Receiver for Chrome session.  Session sends a message when the virtual channel is initialized to the third-party Chrome app. The Virtual Channel SDK handles the message and calls the callback set for the  driverOpen  during virtual channel registration by giving session Id and stream name. Callback present in the third-party Chrome app must reply with enable flag set to  true  or  false  along with the  sessionId  and the virtual channel name. If enable is set to  true , further initialization of the virtual channel happens. Otherwise the virtual channel is ignored. If the virtual channel is not registered with SDK then the virtual channel is ignored.  On sending enable  true , session would send another message to collect the virtual channel information that must be sent to server during initialization. SDK would get the message and call the callback registered for driver info of the registered vc object. Callback present in third-party Chrome app must reply with the appropriate packet if applicable or reply with null.  Session would send all the capabilities to the server and on successful initialization of virtual channel any data sent by server to Citrix Receiver for Chrome session is forwarded to the Virtual Channel SDK.  Virtual Channel SDK calls the  icaDataArrival  callback of the registered virtual channel object. Callback should parse the packet and send the reply packet using  sendData  method of the registered virtual channel object. Utils has been provided to make packet reading and construction of reply packet easier.  On disconnect of the session or the reload/crash/uninstall of the third-party Chrome app Virtual Channel SDK calls the  driverClose  callback of the third-party Chrome app with appropriate session Id and stream name. Can be used to handle any cleanup of the virtual channel for that session.", 
            "title": "Receiver and Virtual Driver Interaction"
        }, 
        {
            "location": "/system-requirements/#see-also", 
            "text": "For sample example, see the  download  page.  For details on signature and usage of APIs, see the  Programming Guide .", 
            "title": "See also"
        }, 
        {
            "location": "/system-requirements/#virtual-channel-packets", 
            "text": "ICA does not define the contents of a virtual channel packet. The contents are specific to the particular virtual channel and are not interpreted or managed by the ICA data stream manager. You must develop your own protocol for the virtual channel data.  A virtual channel packet can be any length up to the maximum size supported by the ICA connection. This size is independent of size restrictions on the lower-layer transport. These restrictions affect the server-side WFVirtualChannelRead and WFVirtualChannelWrite functions and sendData callback on the client side. The maximum packet size is 5000 bytes (4996 data bytes plus 4 bytes of packet overhead generated by the ICA datastream manager).  Because Citrix Receiver for Chrome and the Virtual Channel SDK for Chrome are not aware of the details of the virtual channel package, they pass all available data in the ICA stream to the virtual driver by calling  icaDataArrival . Packets received by the icaDataArrival function of the virtual channel are Uint8Arrays with appropriate details of offset and length. The virtual channel also needs to send the data to server in the same format. \nThe session creates a port connection using Chrome APIs and the data is sent/received over this port. Maximum size of the data that can be sent/received is dependent on the Chrome OS implementation.", 
            "title": "Virtual Channel Packets"
        }, 
        {
            "location": "/using-example-programs/", 
            "text": "Using example programs\n\n\nThe example programs included with the Virtual Channel SDK are buildable, working virtual channels. Use these examples to:\n\n\n\n\nVerify your Virtual Channel SDK is correct by building a known working example program.\n\n\nProvide working examples of code that can be modified to suit your requirements.\n\n\nExplore the features and functionality provided in the Virtual Channel SDK.\n\n\n\n\nEach of these example programs comprises a client virtual driver and a server application. The server-side application is run from the command line within an ICA session. A single virtual channel comprises an application pair.\n\n\nThe example programs included with the Virtual Channel SDK are:\n\n\n\n\nPing: Records the round-trip delay time for a test packet sent over a virtual channel.\n\n\nMix: Demonstrates a mechanism to call functions (for example, to get the time of day) on a remote client.\n\n\nOver: Simple asynchronous application that demonstrates how to code an application where the server must receive a response from the client asynchronously and where the type of packet being sent to the client is different from the type received.\n\n\n\n\nEach example includes a description of the program, packet format, and other necessary information and demonstrates the following:\n\n\n\n\nHow to include Virtual Channel SDK the JavaScript file within the Chrome packaged app. \n\n\nHow to register the virtual channel to the SDK.\n\n\nHow to handle driverOpen, driverInfo, icaDataArrival, driverClose and sendData.\n\n\nHow to use utils to read the packet in Uint8Array format and also construction of reply packet using utils.\n\n\n\n\nPing\n\n\nPing is a simple program that records the round-trip delay time for a test packet sent over a virtual channel. The server sends a packet to the client and the client responds with a packet containing the time it received the original packet from the server. This sequence is repeated a specified number of times, and then the program displays the round-trip time for each ping and the average round-trip delay time.\n\n\nFor this example, there is no significant difference between a BEGIN packet and an END packet. The two types of packets are provided as an example for writing your own virtual channel protocols.\n\n\nPacket Format\n\n\nThe following packet is exchanged between the client and the server.\n\n\nByte 0-1 uSign; // Signature\nByte 2-3 uType; // Type, BEGIN or END, from server\nByte 4-5 uLen; // Packet length from server\nByte 6-7 uCounter; // Sequencer\nByte 8-11 ulServerMS; // Server millisecond clock\nByte 12-15 ulClientMS; // Client millisecond clock\n\n\n\n\n\nMix\n\n\nMix demonstrates a mechanism that you can use to call functions on a remote client (for example to get the time of day). This program demonstrates an extensible scheme for making function calls from the server to the client that allows the server to specify when it expects a response from the client and when it does not. This method can increase performance, because the server does not have to constantly wait for a reply from the client.\n\n\nThe server calls a series of simple functions:\n\n\n\n\nAddNo\n: Add two numbers and return the sum as the return value.\n\n\nDispStr\n: Write a string to the log file. There is no return value (write-only function).\n\n\nGettime\n: Read the client time and return it as the return value.\n\n\n\n\nThe actual implementation of these functions is on the client side. The server conditionally waits for the response from the client, depending on the function being executed. For example, the server waits for the result of the\u00a0\nAddNo\n\u00a0or\u00a0\nGettime\n\u00a0function, but not the write-only function\u00a0\nDispStr\n, which returns no result.\n\n\nPacket Format\n\n\nByte 0-1 uType // Packet type\nByte 2-3 uFunc; // Index of Function\nByte 4-7 uLen; // Length of data\nByte 8-9 fRetReq; // True if return value required\nByte 10-13 dwRetVal; // Return Value from client\nByte 14-15 dwLen1; // length of data for \\#1 LpVoid\nByte 16-17 dwLen2; // length of data for \\#2 LpVoid\n\n\n\n\n\nThe data consists of the structure above followed by the arguments to the function being called. uLen is the total length of the data being sent, including the arguments. DwLen1 is the length of the data pointed to by a pointer argument.\n\n\nSequence of Events\n\n\nThe Mix program demonstrates the following sequence of events. The following figure illustrates the sequence of events that occur when you use the Mix program, starting at the top:\n\n\n\n\nOver\n\n\nOver is a simple asynchronous application. It demonstrates how to code an application in which the server must receive a response from the client asynchronously, and the type of packet being sent to the client is different from the type received.\n\n\nWhen the Over program begins, it:\n\n\n\n\nSpawns a thread that waits for a response from the client.\n\n\nBegins sending data packets with sequence numbers to the client.\n\n\n(After sending the last packet of data) sends a packet with a sequence number of\u00a0\nNO\\_MORE\\_DATA\n, and then closes the connection.\n\n\n\n\nThe client receives packets and inspects the sequence number. For every sequence number divisible by 10, the client increases the sequence number by 7 and sends a response to the server. These numbers are chosen arbitrarily to demonstrate that the client can asynchronously send data to the server at any time.\n\n\nThe packet type used to send data from the server to the client is different from the packet type used to receive data from the client.\n\n\nPacket Format - From Server to Client\n\n\nByte 0-1 uSign; // Signature\nByte 2-3 uType; // Type, BEGIN or END, from server\nByte 4-5 uLen; // Packet length from server\nByte 6-7 uCounter; // Sequencer\nByte 8-11 ulServerMS; // Server millisecond clock\n\n\n\n\n\nPacket Format - From Client to Server\n\n\nByte 0-1 uType; // Type OVERFLOW\\_JUMP from client\nByte 2-3 uLen; // Packet length from client\nByte 4-5 uCounter; // seqUencer\n\n\n\n\n\nSequence of Events\n\n\nThis figure illustrates the sequence of events that occur when you use the Over program, starting at the top.", 
            "title": "Using example programs"
        }, 
        {
            "location": "/using-example-programs/#using-example-programs", 
            "text": "The example programs included with the Virtual Channel SDK are buildable, working virtual channels. Use these examples to:   Verify your Virtual Channel SDK is correct by building a known working example program.  Provide working examples of code that can be modified to suit your requirements.  Explore the features and functionality provided in the Virtual Channel SDK.   Each of these example programs comprises a client virtual driver and a server application. The server-side application is run from the command line within an ICA session. A single virtual channel comprises an application pair.  The example programs included with the Virtual Channel SDK are:   Ping: Records the round-trip delay time for a test packet sent over a virtual channel.  Mix: Demonstrates a mechanism to call functions (for example, to get the time of day) on a remote client.  Over: Simple asynchronous application that demonstrates how to code an application where the server must receive a response from the client asynchronously and where the type of packet being sent to the client is different from the type received.   Each example includes a description of the program, packet format, and other necessary information and demonstrates the following:   How to include Virtual Channel SDK the JavaScript file within the Chrome packaged app.   How to register the virtual channel to the SDK.  How to handle driverOpen, driverInfo, icaDataArrival, driverClose and sendData.  How to use utils to read the packet in Uint8Array format and also construction of reply packet using utils.", 
            "title": "Using example programs"
        }, 
        {
            "location": "/using-example-programs/#ping", 
            "text": "Ping is a simple program that records the round-trip delay time for a test packet sent over a virtual channel. The server sends a packet to the client and the client responds with a packet containing the time it received the original packet from the server. This sequence is repeated a specified number of times, and then the program displays the round-trip time for each ping and the average round-trip delay time.  For this example, there is no significant difference between a BEGIN packet and an END packet. The two types of packets are provided as an example for writing your own virtual channel protocols.", 
            "title": "Ping"
        }, 
        {
            "location": "/using-example-programs/#packet-format", 
            "text": "The following packet is exchanged between the client and the server.  Byte 0-1 uSign; // Signature\nByte 2-3 uType; // Type, BEGIN or END, from server\nByte 4-5 uLen; // Packet length from server\nByte 6-7 uCounter; // Sequencer\nByte 8-11 ulServerMS; // Server millisecond clock\nByte 12-15 ulClientMS; // Client millisecond clock", 
            "title": "Packet Format"
        }, 
        {
            "location": "/using-example-programs/#mix", 
            "text": "Mix demonstrates a mechanism that you can use to call functions on a remote client (for example to get the time of day). This program demonstrates an extensible scheme for making function calls from the server to the client that allows the server to specify when it expects a response from the client and when it does not. This method can increase performance, because the server does not have to constantly wait for a reply from the client.  The server calls a series of simple functions:   AddNo : Add two numbers and return the sum as the return value.  DispStr : Write a string to the log file. There is no return value (write-only function).  Gettime : Read the client time and return it as the return value.   The actual implementation of these functions is on the client side. The server conditionally waits for the response from the client, depending on the function being executed. For example, the server waits for the result of the\u00a0 AddNo \u00a0or\u00a0 Gettime \u00a0function, but not the write-only function\u00a0 DispStr , which returns no result.", 
            "title": "Mix"
        }, 
        {
            "location": "/using-example-programs/#packet-format_1", 
            "text": "Byte 0-1 uType // Packet type\nByte 2-3 uFunc; // Index of Function\nByte 4-7 uLen; // Length of data\nByte 8-9 fRetReq; // True if return value required\nByte 10-13 dwRetVal; // Return Value from client\nByte 14-15 dwLen1; // length of data for \\#1 LpVoid\nByte 16-17 dwLen2; // length of data for \\#2 LpVoid  The data consists of the structure above followed by the arguments to the function being called. uLen is the total length of the data being sent, including the arguments. DwLen1 is the length of the data pointed to by a pointer argument.", 
            "title": "Packet Format"
        }, 
        {
            "location": "/using-example-programs/#sequence-of-events", 
            "text": "The Mix program demonstrates the following sequence of events. The following figure illustrates the sequence of events that occur when you use the Mix program, starting at the top:", 
            "title": "Sequence of Events"
        }, 
        {
            "location": "/using-example-programs/#over", 
            "text": "Over is a simple asynchronous application. It demonstrates how to code an application in which the server must receive a response from the client asynchronously, and the type of packet being sent to the client is different from the type received.  When the Over program begins, it:   Spawns a thread that waits for a response from the client.  Begins sending data packets with sequence numbers to the client.  (After sending the last packet of data) sends a packet with a sequence number of\u00a0 NO\\_MORE\\_DATA , and then closes the connection.   The client receives packets and inspects the sequence number. For every sequence number divisible by 10, the client increases the sequence number by 7 and sends a response to the server. These numbers are chosen arbitrarily to demonstrate that the client can asynchronously send data to the server at any time.  The packet type used to send data from the server to the client is different from the packet type used to receive data from the client.", 
            "title": "Over"
        }, 
        {
            "location": "/using-example-programs/#packet-format-from-server-to-client", 
            "text": "Byte 0-1 uSign; // Signature\nByte 2-3 uType; // Type, BEGIN or END, from server\nByte 4-5 uLen; // Packet length from server\nByte 6-7 uCounter; // Sequencer\nByte 8-11 ulServerMS; // Server millisecond clock", 
            "title": "Packet Format - From Server to Client"
        }, 
        {
            "location": "/using-example-programs/#packet-format-from-client-to-server", 
            "text": "Byte 0-1 uType; // Type OVERFLOW\\_JUMP from client\nByte 2-3 uLen; // Packet length from client\nByte 4-5 uCounter; // seqUencer", 
            "title": "Packet Format - From Client to Server"
        }, 
        {
            "location": "/using-example-programs/#sequence-of-events_1", 
            "text": "This figure illustrates the sequence of events that occur when you use the Over program, starting at the top.", 
            "title": "Sequence of Events"
        }, 
        {
            "location": "/building-examples/", 
            "text": "Building examples\n\n\nBuilding a server-side example using \nNmake\n\n\nExamples of the latest server-side executables have been provided for testing. You can download the latest Windows Virtual Channel SDK in order to develop the server-side component.\n\n\nBuilding a client-side example\n\n\nFor example on sample apps, see the \ndownload\n page. \n\n\nLoading Sample virtual channel apps\n\n\nCitrix provides Chrome packaged apps for each of the example virtual channel. You can load the apps using the following steps\n\n\n\n\nOpen new tab in Chrome browser\n\n\nOpen \nchrome://extensions\n\n\nEnsure the Developer mode checkbox is ticked.\n\n\nClick on load unpacked extensions\n\n\nPoint to the third-party sample app (for example, Ping)\n\n\nYou can see the app Id which needs to be used to configure Receiver.\n\n\n\n\nConfiguring the Receiver\n\n\nUse one of the configuration methods provided for Receiver for Chrome configuration.\n\n\nRecommended is to push policy using Google Admin Console. The following represents a sample policy file:\n\n\n{\n    \nsettings\n: {\n        \nValue\n: {\n            \nsettings_version\n: \n1.0\n,\n            \nengine_settings\n: {\n                \ncustomVC\n: [ \n                    { // Should be repeated for each virtual channel to be added. Up to 3 virtual channels are supported.\n                     \nappId\n: \nthird_party_chrome_app_id1\n, //Id of the ping or mix or over apps or your own app.\n                     \nstreamName\n: \nvirtual channel name1\n //Here, CTXPING, Mix, or CTXOVER based on the VC you want to try.\n                    } \n                ]\n            }\n        }\n    }\n}\n\n\n\n\n\nRunning an Example Virtual Channel\n\n\n\n\nCopy the server side executables.\n\n\nOn the client,\n\n\nInstall the third-party Chrome app implementing the virtual channel\n\n\nConfigure Receiver for Chrome.\n\n\nLaunch session using Receiver for Chrome.", 
            "title": "Building examples"
        }, 
        {
            "location": "/building-examples/#building-examples", 
            "text": "", 
            "title": "Building examples"
        }, 
        {
            "location": "/building-examples/#building-a-server-side-example-using-nmake", 
            "text": "Examples of the latest server-side executables have been provided for testing. You can download the latest Windows Virtual Channel SDK in order to develop the server-side component.", 
            "title": "Building a server-side example using Nmake"
        }, 
        {
            "location": "/building-examples/#building-a-client-side-example", 
            "text": "For example on sample apps, see the  download  page.", 
            "title": "Building a client-side example"
        }, 
        {
            "location": "/building-examples/#loading-sample-virtual-channel-apps", 
            "text": "Citrix provides Chrome packaged apps for each of the example virtual channel. You can load the apps using the following steps   Open new tab in Chrome browser  Open  chrome://extensions  Ensure the Developer mode checkbox is ticked.  Click on load unpacked extensions  Point to the third-party sample app (for example, Ping)  You can see the app Id which needs to be used to configure Receiver.", 
            "title": "Loading Sample virtual channel apps"
        }, 
        {
            "location": "/building-examples/#configuring-the-receiver", 
            "text": "Use one of the configuration methods provided for Receiver for Chrome configuration.  Recommended is to push policy using Google Admin Console. The following represents a sample policy file:  {\n     settings : {\n         Value : {\n             settings_version :  1.0 ,\n             engine_settings : {\n                 customVC : [ \n                    { // Should be repeated for each virtual channel to be added. Up to 3 virtual channels are supported.\n                      appId :  third_party_chrome_app_id1 , //Id of the ping or mix or over apps or your own app.\n                      streamName :  virtual channel name1  //Here, CTXPING, Mix, or CTXOVER based on the VC you want to try.\n                    } \n                ]\n            }\n        }\n    }\n}", 
            "title": "Configuring the Receiver"
        }, 
        {
            "location": "/building-examples/#running-an-example-virtual-channel", 
            "text": "Copy the server side executables.  On the client,  Install the third-party Chrome app implementing the virtual channel  Configure Receiver for Chrome.  Launch session using Receiver for Chrome.", 
            "title": "Running an Example Virtual Channel"
        }, 
        {
            "location": "/programming-guide/", 
            "text": "Programming guide\n\n\nVirtual channels are referred to by a seven-character (or shorter) ASCII name. In several previous versions of the ICA protocol, virtual channels were numbered; the numbers are now assigned dynamically based on the ASCII name, making implementation easier.\n\n\nWhen developing virtual channel code for internal use only, you can use any seven-character name that does not conflict with existing virtual channels. Use only upper and lowercase ASCII letters and numbers. Follow the existing naming convention when adding your own virtual channels.\n\n\nThe predefined channels, which begin with the OEM identifier CTX, are for use only by Citrix.\n\n\nDesign Suggestions\n\n\nFollow these suggestions to make your virtual channels easier to design and enhance:\n\n\n\n\nWhen you design your own virtual channel protocol, allow for the flexibility to add features. Virtual channels have version numbers that are exchanged during initialization so that both the client and the server detect the maximum level of functionality that can be used. For example, if the client is at Version 3 and the server is at Version 5, the server does not send any packets with functionality beyond Version 3 because the client does not know how to interpret the newer packets.\n\n\nBecause the server side of a virtual channel protocol can be implemented as a separate process, it is easier to write code that interfaces with the Citrix-provided virtual channel support on the server than on the client (where the code must fit into an existing code structure). The server side of a virtual channel simply opens the channel, reads from and writes to it, and closes it when done. Writing code for the server-side is similar to writing an application, which uses services exported by the system. It is easier to write an application to handle the virtual channel communication because it can then be run once for each ICA connection supporting the virtual channel. Writing for the client-side is similar to writing a driver, which must provide services to the system in addition to using system services. If a service is written, it must manage multiple connections.\n\n\nIf you are designing new hardware for use with new virtual channels (for example, an improved compressed video format), make sure the hardware can be detected so that the client can determine whether or not it is installed. Then the client can communicate to the server if the hardware is available before the server uses the new data format. Optionally, you could have the virtual driver translate the new data format for use with older hardware.\n\n\nThere might be limitations preventing your new virtual channel from performing at an optimum level. If the client is connecting to the server running XenApp through a modem or serial connection, the bandwidth might not be great enough to properly support audio or video data. You can make your protocol adaptive, so that as bandwidth decreases, performance degrades gracefully, possibly by sending sound normally but reducing the frame rate of the video to fit the available bandwidth.\n\n\nTo identify where problems are occurring (connection, implementation, or protocol), first get the connection and communication working. Then, after the virtual channel is complete and debugged, do some time trials and record the results. These results establish a baseline for measuring further optimizations such as compression and other enhancements so that the channel requires less bandwidth.\n\n\nThe time stamp in the pVdPoll variable can be helpful for resolving timing issues in your virtual driver. It is a ULONG containing the current time in milliseconds. The pVdPoll variable is a pointer to a DLLPOLL structure. See Dllapi.h (in src/inc/) for definitions of these structures.\n\n\n\n\nServer-Side Functions Overview\n\n\nFor information on configuring server-side functionalities on the SDK, see \nXenApp and XenDesktop SDK\n.", 
            "title": "Programming guide"
        }, 
        {
            "location": "/programming-guide/#programming-guide", 
            "text": "Virtual channels are referred to by a seven-character (or shorter) ASCII name. In several previous versions of the ICA protocol, virtual channels were numbered; the numbers are now assigned dynamically based on the ASCII name, making implementation easier.  When developing virtual channel code for internal use only, you can use any seven-character name that does not conflict with existing virtual channels. Use only upper and lowercase ASCII letters and numbers. Follow the existing naming convention when adding your own virtual channels.  The predefined channels, which begin with the OEM identifier CTX, are for use only by Citrix.", 
            "title": "Programming guide"
        }, 
        {
            "location": "/programming-guide/#design-suggestions", 
            "text": "Follow these suggestions to make your virtual channels easier to design and enhance:   When you design your own virtual channel protocol, allow for the flexibility to add features. Virtual channels have version numbers that are exchanged during initialization so that both the client and the server detect the maximum level of functionality that can be used. For example, if the client is at Version 3 and the server is at Version 5, the server does not send any packets with functionality beyond Version 3 because the client does not know how to interpret the newer packets.  Because the server side of a virtual channel protocol can be implemented as a separate process, it is easier to write code that interfaces with the Citrix-provided virtual channel support on the server than on the client (where the code must fit into an existing code structure). The server side of a virtual channel simply opens the channel, reads from and writes to it, and closes it when done. Writing code for the server-side is similar to writing an application, which uses services exported by the system. It is easier to write an application to handle the virtual channel communication because it can then be run once for each ICA connection supporting the virtual channel. Writing for the client-side is similar to writing a driver, which must provide services to the system in addition to using system services. If a service is written, it must manage multiple connections.  If you are designing new hardware for use with new virtual channels (for example, an improved compressed video format), make sure the hardware can be detected so that the client can determine whether or not it is installed. Then the client can communicate to the server if the hardware is available before the server uses the new data format. Optionally, you could have the virtual driver translate the new data format for use with older hardware.  There might be limitations preventing your new virtual channel from performing at an optimum level. If the client is connecting to the server running XenApp through a modem or serial connection, the bandwidth might not be great enough to properly support audio or video data. You can make your protocol adaptive, so that as bandwidth decreases, performance degrades gracefully, possibly by sending sound normally but reducing the frame rate of the video to fit the available bandwidth.  To identify where problems are occurring (connection, implementation, or protocol), first get the connection and communication working. Then, after the virtual channel is complete and debugged, do some time trials and record the results. These results establish a baseline for measuring further optimizations such as compression and other enhancements so that the channel requires less bandwidth.  The time stamp in the pVdPoll variable can be helpful for resolving timing issues in your virtual driver. It is a ULONG containing the current time in milliseconds. The pVdPoll variable is a pointer to a DLLPOLL structure. See Dllapi.h (in src/inc/) for definitions of these structures.", 
            "title": "Design Suggestions"
        }, 
        {
            "location": "/programming-guide/#server-side-functions-overview", 
            "text": "For information on configuring server-side functionalities on the SDK, see  XenApp and XenDesktop SDK .", 
            "title": "Server-Side Functions Overview"
        }, 
        {
            "location": "/known-limitations/", 
            "text": "Known limitations\n\n\n\n\nVirtual Channel SDK is not supported in KIOSK mode", 
            "title": "Known limitations"
        }, 
        {
            "location": "/known-limitations/#known-limitations", 
            "text": "Virtual Channel SDK is not supported in KIOSK mode", 
            "title": "Known limitations"
        }, 
        {
            "location": "/programming-reference/", 
            "text": "Programming reference\n\n\nVirtual Channel SDK for Receiver for Chrome enables third-party Chrome apps to write custom virtual channels.\n\n\nThese channels negotiated are initialized with the app/desktop sessions launched using Receiver for Chrome or using HDX SDK for Chrome.\n\n\nAlso, the Virtual Channel SDK gives an easy way to write and receive the data from the third-party Chrome app and the app/desktop.\n\n\nGetting Started\n\n\n\n\nCopy \nCitrixChromeVCSDK.js\n to the third-party Chrome app.\n\n\nInclude \nCitrixChromeVCSDK.js\n in the background scripts of the third-party Chrome app.\n\n\nEnsure to use the APIs only after all the background scripts are loaded.\n\n\nRegister the virtual channel and store the virtual channel object returned.\n\n\nAppropriate callbacks registered would be called for various actions.\n\n\nUse sendData method to send any packet to the session.\n\n\nAll the registered virtual channels are now initialized with each app/desktop session launched.\n\n\n\n\nPrerequisite\n\n\nEach third-party Chrome app along with the Virtual channel stream name has to be sent as configuration to the Receiver", 
            "title": "Programming reference"
        }, 
        {
            "location": "/programming-reference/#programming-reference", 
            "text": "Virtual Channel SDK for Receiver for Chrome enables third-party Chrome apps to write custom virtual channels.  These channels negotiated are initialized with the app/desktop sessions launched using Receiver for Chrome or using HDX SDK for Chrome.  Also, the Virtual Channel SDK gives an easy way to write and receive the data from the third-party Chrome app and the app/desktop.", 
            "title": "Programming reference"
        }, 
        {
            "location": "/programming-reference/#getting-started", 
            "text": "Copy  CitrixChromeVCSDK.js  to the third-party Chrome app.  Include  CitrixChromeVCSDK.js  in the background scripts of the third-party Chrome app.  Ensure to use the APIs only after all the background scripts are loaded.  Register the virtual channel and store the virtual channel object returned.  Appropriate callbacks registered would be called for various actions.  Use sendData method to send any packet to the session.  All the registered virtual channels are now initialized with each app/desktop session launched.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/programming-reference/#prerequisite", 
            "text": "Each third-party Chrome app along with the Virtual channel stream name has to be sent as configuration to the Receiver", 
            "title": "Prerequisite"
        }
    ]
}